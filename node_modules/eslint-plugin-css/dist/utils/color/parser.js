"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseArgumentValuesWithComma = exports.parseArgumentValuesWithSpace = exports.parseArgumentValues = exports.isPercentRange = exports.parseInput = exports.parseNumberUnit = exports.parseFunction = exports.ValuesArgumentIncomplete = exports.ValuesArgumentComplete = exports.AlphaArgumentInvalid = exports.AlphaArgumentValid = exports.AbsAlphaArgument = exports.FunctionArgument = void 0;
const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));
class FunctionArgument {
    constructor(before, node, after) {
        this.raws = {
            before,
            after: after || "",
        };
        this.node = node;
    }
    toString() {
        return `${this.raws.before}${postcss_value_parser_1.default.stringify(this.node)}${this.raws.after}`;
    }
}
exports.FunctionArgument = FunctionArgument;
class AbsAlphaArgument {
    constructor(div, tokens, alpha) {
        this.div = div;
        this.tokens = tokens;
        this.value = alpha;
    }
    toAlphaString() {
        return this.tokens.join("");
    }
    toString() {
        return `${this.div}${this.toAlphaString()}`;
    }
}
exports.AbsAlphaArgument = AbsAlphaArgument;
class AlphaArgumentValid extends AbsAlphaArgument {
    get valid() {
        return true;
    }
}
exports.AlphaArgumentValid = AlphaArgumentValid;
class AlphaArgumentInvalid extends AbsAlphaArgument {
    get valid() {
        return false;
    }
}
exports.AlphaArgumentInvalid = AlphaArgumentInvalid;
class AbsValuesArgument {
    constructor(tokens, value) {
        this.tokens = tokens;
        this.value = value;
    }
    toString() {
        return this.tokens.join("");
    }
}
class ValuesArgumentComplete extends AbsValuesArgument {
    constructor() {
        super(...arguments);
        this.complete = true;
    }
}
exports.ValuesArgumentComplete = ValuesArgumentComplete;
class ValuesArgumentIncomplete extends AbsValuesArgument {
    constructor(tokens) {
        super(tokens, null);
        this.complete = false;
    }
}
exports.ValuesArgumentIncomplete = ValuesArgumentIncomplete;
function parseFunction(input, expectName) {
    const node = parseInput(input);
    if (!node) {
        return null;
    }
    if (node.type !== "function") {
        return null;
    }
    if (Array.isArray(expectName)
        ? !expectName.includes(node.value.toLowerCase())
        : node.value.toLowerCase() !== expectName) {
        return null;
    }
    const argumentList = [];
    let before = node.before;
    for (const argNode of node.nodes) {
        if (argNode.type !== "comment" && argNode.type !== "space") {
            argumentList.push({ before, node: argNode });
            before = "";
        }
        else {
            before += postcss_value_parser_1.default.stringify(argNode);
        }
    }
    if (argumentList.length > 0) {
        argumentList[argumentList.length - 1].after = `${before}${node.after}`;
    }
    return {
        rawName: node.value,
        arguments: argumentList.map((data) => new FunctionArgument(data.before, data.node, data.after)),
    };
}
exports.parseFunction = parseFunction;
function parseNumberUnit(input, expectUnits) {
    if (!input) {
        return null;
    }
    if (input.node.type !== "word") {
        return null;
    }
    const data = postcss_value_parser_1.default.unit(input.node.value);
    if (!data) {
        return null;
    }
    if (!expectUnits.includes(data.unit)) {
        return null;
    }
    return {
        number: Number(data.number),
        unit: data.unit,
    };
}
exports.parseNumberUnit = parseNumberUnit;
function parseAlphaArgument(div, functionArguments) {
    const tokens = [];
    const alphaNode = functionArguments.shift();
    if (!alphaNode) {
        return new AlphaArgumentInvalid(div, tokens, null);
    }
    tokens.push(alphaNode);
    if (functionArguments.length) {
        while (functionArguments.length) {
            tokens.push(functionArguments.shift());
        }
        return new AlphaArgumentInvalid(div, tokens, null);
    }
    const alphaData = parseNumberUnit(alphaNode, ["", "%"]);
    if (!alphaData) {
        return new AlphaArgumentInvalid(div, tokens, null);
    }
    const alphaValue = alphaData.number / (alphaData.unit === "%" ? 100 : 1);
    if (alphaValue >= 0 && alphaValue <= 1) {
        return new AlphaArgumentValid(div, tokens, alphaValue);
    }
    return new AlphaArgumentInvalid(div, tokens, alphaValue);
}
function parseInput(input) {
    if (typeof input === "string") {
        const parsed = (0, postcss_value_parser_1.default)(input);
        if (parsed.nodes.length !== 1) {
            return null;
        }
        return parsed.nodes[0];
    }
    return input !== null && input !== void 0 ? input : null;
}
exports.parseInput = parseInput;
function isPercentRange(node) {
    return Boolean(node && node.number >= 0 && node.number <= 100);
}
exports.isPercentRange = isPercentRange;
function parseArgumentValues(functionArguments, option) {
    if (functionArguments.some((t) => t.node.value === ",")) {
        return parseArgumentValuesWithComma(functionArguments, option);
    }
    return parseArgumentValuesWithSpace(functionArguments, option);
}
exports.parseArgumentValues = parseArgumentValues;
function parseArgumentValuesWithSpace(functionArguments, option) {
    let alpha = null;
    const tokens = [];
    while (functionArguments.length) {
        const token = functionArguments.shift();
        if (token.node.value === "/") {
            alpha = parseAlphaArgument(token, functionArguments);
            break;
        }
        tokens.push(token);
    }
    if (tokens.length) {
        const value = option.generate(tokens);
        if (value) {
            return {
                values: new ValuesArgumentComplete(tokens, value),
                alpha,
            };
        }
    }
    return {
        values: new ValuesArgumentIncomplete(tokens),
        alpha,
    };
}
exports.parseArgumentValuesWithSpace = parseArgumentValuesWithSpace;
function parseArgumentValuesWithComma(functionArguments, option) {
    let commaCount = 0;
    let alpha = null;
    const tokens = [];
    while (functionArguments.length) {
        const token = functionArguments.shift();
        if (token.node.value === ",") {
            commaCount++;
            if (commaCount >= option.argCount) {
                alpha = parseAlphaArgument(token, functionArguments);
                break;
            }
        }
        tokens.push(token);
    }
    if (tokens.length) {
        const argumentTokens = [];
        let validComma = true;
        let comma = false;
        for (const token of tokens) {
            if (comma) {
                if (token.node.value !== ",") {
                    validComma = false;
                    break;
                }
            }
            else {
                argumentTokens.push(token);
            }
            comma = !comma;
        }
        if (validComma) {
            const value = option.generate(argumentTokens);
            if (value) {
                return {
                    values: new ValuesArgumentComplete(tokens, value),
                    alpha,
                };
            }
        }
    }
    return {
        values: new ValuesArgumentIncomplete(tokens),
        alpha,
    };
}
exports.parseArgumentValuesWithComma = parseArgumentValuesWithComma;
