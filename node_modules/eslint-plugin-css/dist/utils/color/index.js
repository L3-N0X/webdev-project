"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseHexColor = exports.parseColor = void 0;
const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));
const parser_1 = require("./parser");
const hex_1 = require("./hex");
const gray_1 = require("./gray");
const lab_1 = require("./lab");
const hwb_1 = require("./hwb");
const rgb_1 = require("./rgb");
const hsl_1 = require("./hsl");
const lch_1 = require("./lch");
const color_class_1 = require("./color-class");
const colord_1 = require("./colord");
class InvalidColor extends color_class_1.AbsColor {
    constructor(input) {
        super();
        this.type = "invalid";
        this.input = input;
    }
    isComplete() {
        return false;
    }
    getAlpha() {
        return null;
    }
    removeAlpha() {
        return this;
    }
    toColorString() {
        return this.input;
    }
    newColord() {
        return null;
    }
}
class ColorForColord extends color_class_1.AbsColor {
    constructor(input) {
        super();
        this.input = input;
    }
    get type() {
        var _a;
        return ((_a = this.typeCache) !== null && _a !== void 0 ? _a : (this.typeCache = /^[a-z]+$/iu.test(this.input) && (0, colord_1.getColorFormat)(this.input) === "name"
            ? "name"
            : "unknown"));
    }
    isComplete() {
        var _a;
        return ((_a = this.getColord()) === null || _a === void 0 ? void 0 : _a.isValid()) || false;
    }
    getAlpha() {
        var _a, _b;
        return (_b = (_a = this.getColord()) === null || _a === void 0 ? void 0 : _a.alpha()) !== null && _b !== void 0 ? _b : null;
    }
    removeAlpha() {
        return this;
    }
    toColorString() {
        return this.input;
    }
    toNameImpl() {
        return this.type === "name" ? this.input : super.toNameImpl();
    }
    newColord() {
        return (0, colord_1.parseColord)(this.toColorString());
    }
}
function parseColor(input) {
    const hex = (0, hex_1.parseHex)(input);
    if (hex) {
        return new hex_1.ColorFromHex(hex);
    }
    const node = (0, parser_1.parseInput)(input);
    if (node) {
        const rgb = (0, rgb_1.parseRgb)(node);
        if (rgb) {
            return new rgb_1.ColorFromRgb(rgb);
        }
        const hsl = (0, hsl_1.parseHsl)(node);
        if (hsl) {
            return new hsl_1.ColorFromHsl(hsl);
        }
        const hwb = (0, hwb_1.parseHwb)(node);
        if (hwb) {
            return new hwb_1.ColorFromHwb(hwb);
        }
        const lab = (0, lab_1.parseLab)(node);
        if (lab) {
            return new lab_1.ColorFromLab(lab);
        }
        const lch = (0, lch_1.parseLch)(node);
        if (lch) {
            return new lch_1.ColorFromLch(lch);
        }
        const gray = (0, gray_1.parseGray)(node);
        if (gray) {
            return new gray_1.ColorFromGray(gray);
        }
    }
    return new ColorForColord(typeof input === "string" ? input : postcss_value_parser_1.default.stringify(input));
}
exports.parseColor = parseColor;
function parseHexColor(hex) {
    if (!(0, hex_1.isHex)(hex)) {
        return new InvalidColor(hex);
    }
    return parseColor(hex);
}
exports.parseHexColor = parseHexColor;
